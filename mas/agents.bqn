âŸ¨âŸ¨white, black, red, blueâŸ©â‡colorâŸ©â†râ†â€¢Import "../rayed.bqn"

# settings for the simulation
config â† {
    # init settings
    numAgents â‡ 10
    
    # simulation settings
    ## collective of neightbours for the average
    neighWeight â‡ 0.01
    ## min dist between two agents to count as neighbours
    minDist â‡ 0.4
    
    # display settings
    drawRadius â‡ 5
}

# init logic functions

# returns a ğ•©â€¿2 shaped array, so ğ•© (x,y) pairs
# with x and y uniformly distributed between 0 and 1
RandomPairs â† {ğ•Šğ•©: 1000Ã·Ëœğ•©â€¿2 â¥Š (2Ã—ğ•©) â€¢rand.Range 1000}


# update logic functions
Norm  â† âˆšâˆ˜(+Â´)âˆ˜(Ã—ËœÂ¨)
Dist  â† Normâˆ˜-

# takes element, minimum distance, and an array
# returns array of neighbours of element in array
# where neighbours are defined as whatever's below the minimum distance
Neigh â† {eâ€¿mdğ•Šarr: {mdâŠ¸>Ë˜ (eâŠ¸Dist)Ë˜ ğ•©}âŠ¸/ arr}

# splits arr into elements equal to arr and elements not equal to arr
SplitEq â† { eltğ•Šarr: (elt)â‹ˆ(eltâŠ¸â‰¢Ë˜âŠ¸/arr)}

# takes agent and agent vector
# returns new position of the agent as a weighted average of
# - its current position
# - the position of its neighbours (agents closer than config.minDist)
UpdateAgent â† { agentğ•Šagents:
    nwâ€¿md â† âŸ¨config.neighWeight, config.minDistâŸ©
    selfâ€¿n â† agent SplitEq (agentâ€¿md Neigh agents)
    
	# if neighbour list is empty then just return original position
	self 0âŠ¸=âˆ˜(â‰ âˆ˜âŠ¢)â—¶{(ğ•¨Ã—1-nw) + (nwÃ—(+ËÃ·â‰ )ğ•©)}â€¿âŠ£ n
}

# takes array of agents
# returns array of agents that have all been updated according to UpdateAgents
UpdateAgents â† {ğ•Šagents:
    (UpdateAgentâŸœagents)Ë˜agents
}

# return array 4â€¿? shaped array with x1â€¿y1â€¿x2â€¿y2 cells
# where x1 y1, and x2 y2 are the coordinates of two neighbouring agents
# for all pairs of neighbouring agents in the array
# (output meant to be used to draw lines)
NeighbourPairs â† {
    ğ•Šagents:
	md â† config.minDist

	# to avoid detecting both a->b and b->a as neighbour pairs
	# we only compare agents with agents that come after
	# to do this we act on suffices of the agents array

	nes â† Â¯1âŠ¸â†“ â†“ agents # nonempty suffices of the agents vector
	na â† (âŠ {ğ•¨â€¿(ğ•¨â€¿md Neigh ğ•©)} 1âŠ¸â†“)Â¨ nes  # (agentâ€¿neighbours) "alist", or adjacency list
	âˆ¾Â´ {ğ•Šaâ€¿b: aâŠ¸âˆ¾Ë˜ b}Â¨ na

	# {ğ•Šaâ€¿b: aâŠ¸âˆ¾Ë˜ b} takes an alist element and turns it into
	# an array of coords to draw links from that agent to its neighbours
	# do that for all agents then âˆ¾Â´ em up
}

# display functions

# we will simulate agents in a unit square for later convenience
# raylib takes integer coordinates in numbers of pixels

# normalize simulation coordinates (in unit square) to window coordinates
# takes an input in normalized coordinates and turns it into window coordinates
# 
# given that simulation area is currently square,
# and that we want to keep the aspect ratio
# we only scale only by the smaller of the two window dimension
DispCoord â† {
    ğ•Šcoords:
    min â† âŒŠÂ´ r.window.GetSize@
    âŒŠ minâŠ¸Ã— coords
}

# we display the simulation in a square regardless of window aspect ratio
# so it's best to mark out the are we're gonna display in
DrawArena â† {
		  ğ•Š@:
          min â† âŒŠÂ´ r.window.GetSize@
		  64â€¿64â€¿64â€¿255 r.draw.Rectangle [0â€¿0, minâ€¿min]
}

agents â† {
     RandomPairs config.numAgents
}

# display logic
PerFrame â† {
    dr â† config.drawRadius
    DrawArena@
    {white r.draw.Circle âŸ¨(âŒŠÂ¨ğ•©)â‹„drâŸ©}Ë˜DispCoord agents
    
    # segnati il baricentro per vedere come evolve
    # e/o vedere se ci convergono 
    baricenter â† (+ËÃ·â‰ ) agents
    red r.draw.Circle âŸ¨DispCoord baricenter â‹„ drâŸ©
    
    # disegna connessioni tra vari agenti
	segments â† NeighbourPairs agents
	{ğ•Šx1â€¿y1â€¿x2â€¿y2: blue r.draw.Line [x1â€¿y1 â‹„ x2â€¿y2]}Ë˜ DispCoord segments
    
    agents UpdateAgentsâ†©
    
    100|ğ•©+1
}r.draw._withCanvasâŸœblack

PerFrameâ€¢_While_(Â¬r.window.ShouldClose)âˆ˜0 r.window._openAs "Automata"
